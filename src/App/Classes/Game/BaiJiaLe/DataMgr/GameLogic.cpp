//
//  GameLogic.cpp
//  DouDiZhu
//
//  Created by zhong on 1/13/16.
//
//

#include "GameLogic.h"
USING_BJL_NAMESPACE;
//索引变量
const BYTE cbIndexCount=5;

//扑克数据
const BYTE CGameLogic::m_cbCardListData[52*8]=
{
    0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0D,	//方块 A - K
    0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,	//梅花 A - K
    0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2A,0x2B,0x2C,0x2D,	//红桃 A - K
    0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3A,0x3B,0x3C,0x3D,	//黑桃 A - K
    
    0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0D,	//方块 A - K
    0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,	//梅花 A - K
    0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2A,0x2B,0x2C,0x2D,	//红桃 A - K
    0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3A,0x3B,0x3C,0x3D,	//黑桃 A - K
    
    0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0D,	//方块 A - K
    0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,	//梅花 A - K
    0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2A,0x2B,0x2C,0x2D,	//红桃 A - K
    0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3A,0x3B,0x3C,0x3D,	//黑桃 A - K
    
    0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0D,	//方块 A - K
    0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,	//梅花 A - K
    0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2A,0x2B,0x2C,0x2D,	//红桃 A - K
    0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3A,0x3B,0x3C,0x3D,	//黑桃 A - K
    
    0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0D,	//方块 A - K
    0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,	//梅花 A - K
    0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2A,0x2B,0x2C,0x2D,	//红桃 A - K
    0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3A,0x3B,0x3C,0x3D,	//黑桃 A - K
    
    0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0D,	//方块 A - K
    0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,	//梅花 A - K
    0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2A,0x2B,0x2C,0x2D,	//红桃 A - K
    0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3A,0x3B,0x3C,0x3D,	//黑桃 A - K
    
    0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0D,	//方块 A - K
    0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,	//梅花 A - K
    0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2A,0x2B,0x2C,0x2D,	//红桃 A - K
    0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3A,0x3B,0x3C,0x3D,	//黑桃 A - K
    
    0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0D,	//方块 A - K
    0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,	//梅花 A - K
    0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2A,0x2B,0x2C,0x2D,	//红桃 A - K
    0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3A,0x3B,0x3C,0x3D,	//黑桃 A - K
};

CGameLogic* CGameLogic::m_gameInstance = nullptr;

void CGameLogic::init()
{
    m_bJoinGame = false;
    m_bDynamicJoin = false;
    
    m_llTotalScore = 0;
    m_fGameRate = 0.0f;
    m_nTotalRound = 0;
    m_nTotalWinRound = 0;
}

//混乱扑克
void CGameLogic::RandCardList(BYTE cbCardBuffer[], BYTE cbBufferCount)
{
    //混乱准备
    BYTE cbCardData[CountArray(m_cbCardListData)];
    CopyMemory(cbCardData,m_cbCardListData,sizeof(m_cbCardListData));
    
    //混乱扑克
    BYTE cbRandCount=0,cbPosition=0;
    do
    {
        cbPosition=rand()%(CountArray(cbCardData)-cbRandCount);
        cbCardBuffer[cbRandCount++]=cbCardData[cbPosition];
        cbCardData[cbPosition]=cbCardData[CountArray(cbCardData)-cbRandCount];
    } while (cbRandCount<cbBufferCount);
    
    return;
}

//排列扑克
void CGameLogic::SortCardList(BYTE cbCardData[], BYTE cbCardCount, BYTE cbSortType)
{
    //数目过虑
    if (cbCardCount==0 || cbCardCount > 10) return;
    if (cbSortType==ST_CUSTOM) return;
    
    //转换数值
    BYTE cbSortValue[10];
    for (BYTE i=0;i<cbCardCount;i++)
    {
        cbSortValue[i]=GetCardValue(cbCardData[i]);
    }
    
    //排序操作
    bool bSorted=true;
    BYTE cbSwitchData=0,cbLast=cbCardCount-1;
    do
    {
        bSorted=true;
        for (BYTE i=0;i<cbLast;i++)
        {
            if ((cbSortValue[i]<cbSortValue[i+1])||
                ((cbSortValue[i]==cbSortValue[i+1])&&(cbCardData[i]<cbCardData[i+1])))
            {
                //设置标志
                bSorted=false;
                
                //扑克数据
                cbSwitchData=cbCardData[i];
                cbCardData[i]=cbCardData[i+1];
                cbCardData[i+1]=cbSwitchData;
                
                //排序权位
                cbSwitchData=cbSortValue[i];
                cbSortValue[i]=cbSortValue[i+1];
                cbSortValue[i+1]=cbSwitchData;
            }
        }
        cbLast--;
    } while(bSorted==false);
    return;
}

//获取牌点
BYTE CGameLogic::GetCardPip(BYTE cbCardData)
{
    //计算牌点
    BYTE cbCardValue=GetCardValue(cbCardData);
    BYTE cbPipCount=(cbCardValue>=10)?0:cbCardValue;
    
    return cbPipCount;
}

//获取牌点
BYTE CGameLogic::GetCardListPip(const BYTE cbCardData[], BYTE cbCardCount)
{
    //变量定义
    BYTE cbPipCount=0;
    
    //获取牌点
    for (BYTE i=0;i<cbCardCount;i++)
    {
        cbPipCount=(GetCardPip(cbCardData[i])+cbPipCount)%10;
    }
    
    return cbPipCount;
}

//计算命中率
void CGameLogic::calcuteRate(const int &nWin, const int &nLost)
{
    m_nTotalRound = m_nTotalRound + nWin + nLost;
    m_nTotalWinRound += nWin;
    
    m_fGameRate = (float)m_nTotalWinRound / (float)m_nTotalRound;
}